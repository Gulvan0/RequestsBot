/**
 * Level utilities
 * @packageDocumentation
 */
import { parse, parseObject, generateDate, decrypt, gdDecodeBase64, decompress, levelKey, GDRequestParams } from '../util';
import Creator from './entityCreator';
import { LevelComment, StatlessSearchedUser, LoggedInUser } from './user';
// TODO: Try to add things to SongAuthor (like get all songs by this author)
/**
 * Information about a song author
 */
class SongAuthor {
    /** @internal */
    constructor(
    /** The author's name */
    name, 
    /** The author's Newgrounds ID */
    id) {
        this.name = name;
        this.id = id;
    }
}
/** @internal */
const DEFAULT_SONGS = [
    ['Stay Inside Me', 'OcularNebula'],
    ['Stereo Madness', 'ForeverBound'],
    ['Back on Track', 'DJVI'],
    ['Polargeist', 'Step'],
    ['Dry Out', 'DJVI'],
    ['Base After Base', 'DJVI'],
    ["Can't Let Go", 'DJVI'],
    ['Jumper', 'Waterflame'],
    ['Time Machine', 'Waterflame'],
    ['Cycles', 'DJVI'],
    ['xStep', 'DJVI'],
    ['Clutterfunk', 'Waterflame'],
    ['Theory of Everything', 'DJ-Nate'],
    ['Electroman Adventures', 'Waterflame'],
    ['Clubstep', 'DJ-Nate'],
    ['Electrodynamix', 'DJ-Nate'],
    ['Hexagon Force', 'Waterflame'],
    ['Blast Processing', 'Waterflame'],
    ['Theory of Everything 2', 'DJ-Nate'],
    ['Geometrical Dominator', 'Waterflame'],
    ['Deadlocked', 'F-777'],
    ['Fingerdash', 'MDK'],
    ['The Seven Seas', 'F-777'],
    ['Viking Arena', 'F-777'],
    ['Airborne Robots', 'F-777'],
    ['The Challenge', 'RobTop'],
    ['Payload', 'Dex Arson'],
    ['Beast Mode', 'Dex Arson'],
    ['Machina', 'Dex Arson'],
    ['Years', 'Dex Arson'],
    ['Frontlines', 'Dex Arson'],
    ['Space Pirates', 'Waterflame'],
    ['Striker', 'Waterflame'],
    ['Round 1', 'Dex Arson'],
    ['Embers', 'Dex Arson'],
    ['Monster Dance Off', 'F-777'],
    ['Press Start', 'MDK'],
    ['Nock Em', 'Bossfight'],
    ['Power Trip', 'Boom Kitty']
];
/**
 * Information about a default song
 */
class DefaultSong {
    /**
     * Creates info about a song
     * @param _creator The associated level's creator
     * @param id The numeric ID of the song
     * @internal
     */
    constructor(_creator, id) {
        this._creator = _creator;
        this.isCustom = false;
        id += 1;
        const song = DEFAULT_SONGS[id];
        this.id = id;
        this.name = song[0];
        this.authorName = song[1];
    }
}
/**
 * Information about a custom song
 */
class CustomSong {
    /**
     * Creates info about a song
     * @param _creator The associated level's creator
     * @param rawData The raw data to parse
     * @internal
     */
    constructor(_creator, d) {
        this._creator = _creator;
        this.isCustom = true;
        this.id = +d[1];
        this.name = d[2];
        this.author = new SongAuthor(d[4], +d[3]);
        this.size = {
            raw: Math.floor(+d[5] * 1048576),
            pretty: d[5] + ' MB'
        };
        this.url = decodeURIComponent(d[10]);
    }
}
/** @internal */
const DIFFICULTY_MAP = {
    [-1]: 'N/A',
    0: 'Auto',
    1: 'Easy',
    2: 'Normal',
    3: 'Hard',
    4: 'Harder',
    5: 'Insane'
};
/** @internal */
const DEMON_DIFFICULTY_MAP = {
    0: 'Any',
    1: 'Easy Demon',
    2: 'Medium Demon',
    3: 'Hard Demon',
    4: 'Insane Demon',
    5: 'Extreme Demon'
};
/**
 * Gets the difficulty data for a given difficulty number returned by the server
 * @param diff The difficulty of the level
 * @param special Whether the level is a demon or an auto (if it is either of those)
 * @returns The difficulty as a full object
 * @internal
 */
const getDifficulty = (diff, special) => {
    const raw = (special === 'auto' ? 0 : diff === 0 ? -1 : diff / 10);
    return {
        raw,
        pretty: special === 'demon' ? DEMON_DIFFICULTY_MAP[raw] : DIFFICULTY_MAP[raw]
    };
};
/** @internal */
const AWARDS = ['None', 'Star', 'Feature', 'Epic'];
/** @internal */
const ORBS = [0, 0, 50, 75, 125, 175, 225, 275, 350, 425, 500];
/**
 * Gets the full award object from an award value
 * @param isRated Whether the level is rated
 * @param feature The position of the level feature
 * @param epic Whether the level is epic
 * @returns The award for the level
 * @internal
 */
const getAward = (isRated, feature, isEpic) => {
    if (feature > 0) {
        const raw = isEpic ? 3 : 2;
        return {
            raw,
            position: feature,
            pretty: AWARDS[raw]
        };
    }
    const raw = isRated ? 1 : 0;
    return {
        raw,
        pretty: AWARDS[raw]
    };
};
/** @internal */
const LEVEL_LENGTH_MAP = {
    0: 'Tiny',
    1: 'Short',
    2: 'Medium',
    3: 'Long',
    4: 'XL'
};
/**
 * Gets the length of a level
 * @param raw The raw length from the server
 * @returns The length of the level in object form
 * @internal
 */
const getLevelLength = (raw) => ({
    raw: raw,
    pretty: LEVEL_LENGTH_MAP[raw]
});
/**
 * Details about a level returned from a search
 */
class SearchedLevel {
    /**
     * Creates info about a Geometry Dash level.
     * @param rawData The raw data to parse
     * @param userData The parsed user data
     * @param songData The parsed song data
     * @internal
     */
    constructor(
    /** @internal */
    _creator, rawData, userData, songData) {
        this._creator = _creator;
        const d = typeof rawData === 'string' ? parse(rawData) : rawData;
        this.name = d[2];
        this.id = +d[1];
        this.version = +d[5];
        this.gameVersion = +d[13];
        const songID = d[35];
        this.song =
            songID === '0'
                ? new DefaultSong(_creator, +d[12])
                : new CustomSong(_creator, (this._songData = songData.find(song => songID === song[1])));
        this.description = gdDecodeBase64(d[3]);
        const user = (this._userData = userData.find(el => el[0] === d[6]) || []);
        this.creator = {
            id: +d[6]
        };
        if (user.length)
            this.creator.accountID = +user[2];
        this.difficulty = {
            stars: +d[18],
            level: getDifficulty(+d[9], !!d[17] ? 'demon' : !!d[25] ? 'auto' : undefined),
            requestedStars: +d[39]
        };
        this.stats = {
            likes: +d[14],
            downloads: +d[10],
            objects: +d[45],
            length: getLevelLength(+d[15])
        };
        this.coins = {
            count: +d[37]
        };
        if (this.coins.count > 0)
            this.coins.areSilver = !!+d[38];
        this.award = getAward(this.difficulty.stars > 0, +d[19], !!+d[42]);
        this.orbs = ORBS[this.difficulty.stars];
        this.diamonds = this.difficulty.stars < 2 ? 0 : this.difficulty.stars + 2;
        const orig = +d[30];
        if (orig)
            this.original = orig;
    }
    /**
     * Get the full level from its searched counterpart.
     * @returns The full level
     * @async
     */
    async resolve() {
        const params = new GDRequestParams({
            levelID: this.id,
            inc: 1,
            extras: 0
        });
        params.authorize('db');
        return new Level(this._creator, await this._creator._client.req('/downloadGJLevel22.php', { method: 'POST', body: params }), this._userData, this._songData);
    }
    /**
     * Gets the level's creator. Will only succeed if the creator is registered
     * @returns The creator if it was registered, otherwise null
     * @async
     */
    async getCreator() {
        return this.creator.accountID
            ? await this._creator._client.users.getByAccountID(this.creator.id)
            : null;
    }
    async getComments(byLikes = false, num) {
        let singleReturn = false;
        if (!num) {
            num = 1;
            singleReturn = true;
        }
        const params = new GDRequestParams({
            count: num,
            levelID: this.id,
            mode: +byLikes,
            page: 0,
            total: 0
        });
        params.authorize('db');
        const data = await this._creator._client.req('/getGJComments21.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return singleReturn ? null : [];
        const comments = data
            .slice(0, data.indexOf('#'))
            .split('|')
            .map(str => {
            const [comment, user] = str.split(':');
            return new LevelComment(this._creator._client.users, new StatlessSearchedUser(this._creator._client.users, user), '1~' + this.id + '~' + comment);
        });
        return singleReturn ? comments[0] : comments;
    }
}
/**
 * Details about a level, including its full representation
 */
class Level extends SearchedLevel {
    /**
     * Creates information about a Geometry Dash level, including its string representation
     * @param _creator The creator of the level
     * @param rawData The raw data to parse
     * @param userData The parsed user data
     * @param songData The parsed song data
     * @internal
     */
    constructor(_creator, rawData, userData, songData) {
        const d = parse(rawData.slice(0, rawData.indexOf('#')));
        super(_creator, d, [userData], [songData]);
        this.uploadedAt = generateDate(d[28]);
        this.updatedAt = generateDate(d[29]);
        if (d[27] === '0') {
            this.copy = { copyable: false };
        }
        else {
            this.copy = { copyable: true };
            if (d[27] !== '1')
                this.copy.password = (+decrypt(d[27], levelKey).slice(1)).toString().padStart(4, '0'); // Working on GDPS support
        }
        this.data = d[4];
    }
    async decodeData(full) {
        const raw = await decompress(this.data);
        if (full) {
            const [rawHeader, ...rawParsedData] = raw.split(';');
            return {
                raw,
                parsed: {
                    meta: parse(rawHeader, ','),
                    objects: rawParsedData.map(parseObject)
                }
            };
        }
        return { raw };
    }
}
/**
 * Details about a level returned from a search, created by a logged in user
 */
class LoggedInSearchedLevel extends SearchedLevel {
    /**
     * Creates info about a Geometry Dash level from a logged in user.
     * @param creator The level creator
     * @param rawData The raw data to parse
     * @param userData The parsed user data
     * @param songData The parsed song data
     * @internal
     */
    constructor(
    /** @internal */
    _creator, creator, rawData, userData, songData) {
        super(_creator, rawData, userData, songData);
        this.creator = creator;
    }
    async getCreator() {
        return this.creator;
    }
    async resolve() {
        const params = new GDRequestParams({
            levelID: this.id,
            inc: 1,
            extras: 0
        });
        params.authorize('db');
        return new LoggedInLevel(this._creator, this.creator, await this._creator._client.req('/downloadGJLevel22.php', { method: 'POST', body: params }), this._userData, this._songData);
    }
    /**
     * Updates the description of the level
     * @param desc The new description of the level
     * @returns Whether setting the new description succeeded
     */
    async updateDescription(desc) {
        const success = await this.creator.updateLevelDescription(this, desc);
        if (success) {
            this.description = desc;
        }
        return success;
    }
}
/**
 * Details about a level, including its full representation and created by a logged in user
 */
class LoggedInLevel extends LoggedInSearchedLevel {
    /**
     * Creates info about a Geometry Dash level from a logged in user.
     * @param creator The level creator
     * @param rawData The raw data to parse
     * @param userData The parsed user data
     * @param songData The parsed song data
     * @internal
     */
    constructor(_creator, creator, rawData, userData, songData) {
        const d = parse(rawData.slice(0, rawData.indexOf('#')));
        super(_creator, creator, rawData, [userData], [songData]);
        this.uploadedAt = generateDate(d[28]);
        this.updatedAt = generateDate(d[29]);
        if (d[27] === '0') {
            this.copy = { copyable: false };
        }
        else {
            this.copy = { copyable: true };
            if (d[27] !== '1')
                this.copy.password = (+decrypt(d[27], levelKey).slice(1)).toString().padStart(4, '0'); // Working on GDPS support
        }
        this.data = d[4];
    }
}
Object.defineProperty(LoggedInLevel.prototype, 'decodeData', Object.getOwnPropertyDescriptor(Level.prototype, 'decodeData'));
/** @internal */
const ORDER_MAP = {
    likes: 0,
    downloads: 1,
    trending: 3,
    recent: 4,
    featured: 6,
    magic: 7,
    awarded: 11,
    hof: 16
};
/** @internal */
const DIFFICULTY_KEYS = Object.keys(DIFFICULTY_MAP).map(v => +v);
/** @internal */
const DEMON_DIFFICULTY_KEYS = Object.keys(DEMON_DIFFICULTY_MAP).map(v => +v);
/** @internal */
const LENGTH_KEYS = Object.keys(LEVEL_LENGTH_MAP);
/**
 * Converts a difficulty to a numeric ID
 * @param diff The difficulty to parse
 * @param isDemon Whether the user asked for a demon
 * @returns The difficulty from the string difficulty and whether to default to demon or not
 * @internal
 */
const diffToString = (diff, isDemon) => {
    if (!diff)
        return isDemon ? ['-2', 0] : ['-'];
    if (diff instanceof Array) {
        return isDemon
            ? ['-2', diff.length > 0 ? diffToString(diff[0], true)[1] : 0]
            : [diff.map(v => diffToString(v, true)[0]).join(',') || '-'];
    }
    if (isDemon === undefined)
        isDemon = typeof diff === 'string' && diff.toLowerCase().includes('demon');
    if (isDemon)
        return [
            '-2',
            typeof diff === 'number'
                ? diff
                : DEMON_DIFFICULTY_KEYS.find(id => DEMON_DIFFICULTY_MAP[id].toLowerCase() === diff.toLowerCase())
        ];
    if (typeof diff !== 'number')
        diff = DIFFICULTY_KEYS.find(id => DIFFICULTY_MAP[id].toLowerCase() === diff.toLowerCase());
    return [diff === -1 ? '0' : diff === 0 ? '-3' : diff.toString() || '-'];
};
/**
 * Converts a client length to a server-compatible length
 * @param len The length to parse
 * @returns A server-compatible length
 * @internal
 */
const lengthToString = (len) => len
    ? len instanceof Array
        ? len.map(lengthToString).join(',')
        : typeof len === 'number'
            ? len.toString()
            : LENGTH_KEYS.find(id => LEVEL_LENGTH_MAP[id].toLowerCase() === len.toLowerCase()) || '-'
    : '-';
/**
 * Gets the params for a certain award search
 * @param award The award to get
 * @returns The params to be inserted to match the given award request
 * @internal
 */
const awardToParams = (award) => {
    if ([3, 'Epic', 'epic'].includes(award))
        return { epic: 1, featured: 1 };
    if ([2, 'Feature', 'feature'].includes(award))
        return { featured: 1 };
    return {};
};
/**
 * Convert a client-provided order into an integer
 * @param order The order to parse
 * @returns The integer order
 * @internal
 */
const orderToInt = (order) => typeof order === 'number' ? order : ORDER_MAP[order];
/**
 * Gets the search params for a given search config
 * @param config The config to get the params for
 * @returns The params that work with the config
 * @internal
 */
const getSearchParams = ({ query = '', difficulty, orderBy = 0, demon, award, length, original = false, twoPlayer = false, coins = false }) => {
    if (typeof query === 'number') {
        query = query.toString();
    }
    else if (query instanceof Array) {
        query = query.join(',');
    }
    const [diff, demonFilter] = diffToString(difficulty, demon);
    const len = lengthToString(length);
    const type = orderToInt(orderBy);
    const extraParams = awardToParams(award);
    const params = new GDRequestParams({
        str: query,
        diff,
        len,
        type,
        ...extraParams
    });
    if (demonFilter)
        params.insertParams({ demonFilter });
    if (original)
        params.insertParams({ original: 1 });
    if (twoPlayer)
        params.insertParams({ twoPlayer: 1 });
    if (coins)
        params.insertParams({ coins: 1 });
    params.authorize('db');
    return params;
};
/**
 * A creator for levels
 */
class LevelCreator extends Creator {
    async get(levelID, resolve = false) {
        const level = await this.search({ query: levelID });
        return resolve ? await level.resolve() : level;
    }
    async byCreator(creator, config = {}, num) {
        const singleReturn = !num;
        if (singleReturn)
            num = 1;
        let id = creator;
        if (typeof creator !== 'number') {
            id = creator.id;
        }
        const params = getSearchParams({
            query: '' + id,
            orderBy: 5,
            ...config
        });
        const numToGet = Math.ceil(num / 10);
        const levels = [];
        for (let i = 0; i < numToGet; i++) {
            params.insertParams({
                page: i
            });
            const data = await this._client.req('/getGJLevels21.php', { method: 'POST', body: params });
            if (data === '-1')
                return singleReturn ? null : levels;
            const [levelString, userString, songString] = data.split('#');
            const parsedUsers = userString.split('|').map(str => str.split(':'));
            const parsedSongs = songString.split('~:~').map(str => parse(str, '~|~'));
            levels.push(...levelString
                .split('|')
                .map(str => creator instanceof LoggedInUser
                ? new LoggedInSearchedLevel(this, creator, str, parsedUsers, parsedSongs)
                : new SearchedLevel(this, str, parsedUsers, parsedSongs)));
        }
        return singleReturn ? levels[0] : levels.slice(0, num);
    }
    async search(config, num) {
        const singleReturn = !num;
        if (singleReturn)
            num = 1;
        const params = getSearchParams(config);
        const numToGet = Math.ceil(num / 10);
        const levels = [];
        for (let i = 0; i < numToGet; i++) {
            params.insertParams({
                page: i
            });
            const data = await this._client.req('/getGJLevels21.php', { method: 'POST', body: params });
            if (data === '-1')
                return singleReturn ? null : levels;
            const [levelString, userString, songString] = data.split('#');
            const parsedUsers = userString.split('|').map(str => str.split(':'));
            const parsedSongs = songString.split('~:~').map(str => parse(str, '~|~'));
            levels.push(...levelString.split('|').map(str => new SearchedLevel(this, str, parsedUsers, parsedSongs)));
        }
        return singleReturn ? levels[0] : levels.slice(0, num);
    }
}
export { SearchedLevel, Level, LevelCreator, LoggedInLevel, LoggedInSearchedLevel, SongAuthor, CustomSong, DefaultSong };
