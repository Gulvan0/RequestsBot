/**
 * User utilities
 * @packageDocumentation
 */
import Creator from './entityCreator';
import { SearchedLevel } from './level';
import { parse, GDRequestParams, accountKey, encrypt, gdDecodeBase64, gdEncodeBase64, udid, uuid, generateDate, genRS, commentKey, commentSalt, likeKey, likeSalt } from '../util';
import sha1 from 'sha1';
/**
 * Converts multiple datatypes into an account
 * @param creator The creator of the caller
 * @param id The identifier in some datatype
 * @returns The account ID from that identifier
 * @async
 * @internal
 */
const convertToAccountID = async (creator, id) => {
    if (typeof id === 'string')
        return (await creator.get(id)).accountID;
    if (id instanceof StatlessSearchedUser || id instanceof User)
        return id.accountID;
    return id;
};
/**
 * A comment made by a Geometry Dash player
 */
class Comment {
    /**
     * Creates a comment from a server response
     * @param data The parsed data for the comment
     * @internal
     */
    constructor(data) {
        this.text = gdDecodeBase64(data[2]);
        this.createdAt = generateDate(data[9]);
        this.id = +data[6];
        this.likes = +data[4];
        this.isSpam = !!+data[7];
    }
}
class AccountComment extends Comment {
    /**
     * Creates info about an account comment
     * @param author The comment's author
     * @param rawData The raw data to parse
     * @internal
     */
    constructor(author, rawData) {
        super(parse(rawData, '~'));
        this.author = author;
    }
}
class LoggedInAccountComment extends AccountComment {
    /**
     * Deletes the comment from the Geometry Dash servers
     * @returns A promise that resolves with a boolean of whether deletion was successful
     * @async
     */
    async delete() {
        return this.author.deleteAccountComment(this);
    }
}
class LevelComment extends Comment {
    /**
     * Creates info about a level comment
     * @param _creator The level creator associated with this comment
     * @param author The comment's author
     * @param rawData The raw data to parse
     * @internal
     */
    constructor(_creator, author, rawData) {
        const d = parse(rawData, '~');
        super(d);
        this.author = author;
        this._creator = _creator;
        this.levelID = +d[1];
        if (d[10] !== '0')
            this.percent = +d[10];
    }
    async getLevel(resolve = false) {
        const level = await this._creator._client.levels.get(this.levelID);
        return resolve ? level.resolve() : level;
    }
}
class LoggedInLevelComment extends LevelComment {
    /**
     * Deletes this comment from the servers
     * @returns Whether the comment deletion was successful
     * @async
     */
    async delete() {
        return await this.author.deleteComment(this);
    }
}
/**
 * A friend request
 */
class FriendRequest {
    /**
     * Create data about a friend request
     * @param data The parsed data to evaluate
     * @internal
     */
    constructor(data) {
        this.id = +data[32];
        this.msg = gdDecodeBase64(data[35]);
        this.read = !+data[41];
    }
}
/**
 * An outgoing friend request
 */
class OutgoingFriendRequest extends FriendRequest {
    /**
     * Creates info about an outgoing friend request
     * @param account The account that sent the friend request
     * @param creator The creator of the user the account belongs to
     * @param rawData The raw data to parse
     */
    constructor(account, creator, rawData) {
        const data = parse(rawData);
        super(data);
        this.from = account;
        this.to = new StatlessSearchedUser(creator, rawData);
    }
    /**
     * Cancels a friend request, deleting it from the server
     * @returns Whether the cancellation was successful
     * @async
     */
    async cancel() {
        return this.from.cancelFriendRequest(this);
    }
}
class IncomingFriendRequest extends FriendRequest {
    /**
     * Creates info about an incoming friend request
     * @param account The account that received the friend request
     * @param creator The creator of the user the account belongs to
     * @param rawData The raw data to parse
     * @internal
     */
    constructor(account, creator, rawData) {
        const data = parse(rawData);
        super(data);
        this.to = account;
        this.from = new StatlessSearchedUser(creator, rawData);
    }
    /**
     * Mark a friend request as read
     * @returns Whether marking as read was successful
     * @async
     */
    async markAsRead() {
        return this.read || (await this.to.markFriendRequestAsRead(this));
    }
    /**
     * Accept a friend request
     * @returns Whether accepting the friend request was successful
     * @async
     */
    async accept() {
        return this.to.acceptFriendRequest(this);
    }
    /**
     * Rejects a friend request, deleting it from the server
     * @returns Whether the rejection was successful
     * @async
     */
    async reject() {
        return this.to.rejectFriendRequest(this);
    }
}
class SearchedMessage {
    /**
     * Creates info about a searched message
     * @param account The account associated with this message
     * @param rawData The raw data to parse (or its parsed form)
     * @internal
     */
    constructor(account, rawData) {
        const d = typeof rawData === 'string' ? parse(rawData) : rawData;
        this.id = +d[1];
        const otherAcc = {
            username: d[6],
            id: +d[3],
            accountID: +d[2]
        };
        const outgoing = !!+d[9];
        this.from = (outgoing ? account : otherAcc);
        this.to = (outgoing ? otherAcc : account);
        this.outgoing = outgoing;
        this.subject = gdDecodeBase64(d[4]);
        this.sentAt = generateDate(d[7]);
        this.read = !+d[8];
    }
    /**
     * Deletes this message from the server
     * @returns Whether the message deletion was successful
     * @async
     */
    async delete() {
        return await (this.outgoing ? this.from : this.to).deleteMessage(this);
    }
    /**
     * Resolves the message into a full message
     * @returns The full message from this searched message
     * @async
     */
    async resolve() {
        return await (this.outgoing ? this.from : this.to).getFullMessage(this);
    }
}
class Message extends SearchedMessage {
    /**
     * Creates info about a message
     * @param account The account associated with this message
     * @param rawData The raw data to parse
     * @internal
     */
    constructor(account, rawData) {
        const d = parse(rawData);
        super(account, d);
        this.body = gdDecodeBase64(d[5]);
    }
}
/** @internal */
const colors = [
    '#7dff00',
    '#00ff00',
    '#00ff7d',
    '#00ffff',
    '#007dff',
    '#0000ff',
    '#7d00ff',
    '#ff00ff',
    '#ff007d',
    '#ff0000',
    '#ff7d00',
    '#ffff00',
    '#ffffff',
    '#b900ff',
    '#ffb900',
    '#000000',
    '#00c8ff',
    '#afafaf',
    '#5a5a5a',
    '#ff7d7d',
    '#00af4b',
    '#007d7d',
    '#004baf',
    '#4b00af',
    '#7d007d',
    '#af004b',
    '#af4b00',
    '#7d7d00',
    '#4baf00',
    '#ff4b00',
    '#963200',
    '#966400',
    '#649600',
    '#009664',
    '#006496',
    '#640096',
    '#960064',
    '#960000',
    '#009600',
    '#000096',
    '#7dffaf',
    '#7d7dff'
];
/**
 * Generates a {@link GDColor} from a number returned by the Geometry Dash servers.
 * @param colorValue The color number from the Geometry Dash servers
 * @returns The {@link GDColor} representing the given color number
 * @internal
 */
const userColor = (colorValue) => ({
    raw: colorValue,
    parsed: colors[colorValue]
});
/** @internal */
const PERMISSIONS = ['User', 'Moderator', 'Elder Moderator'];
/**
 * Generates a {@link Permission} from a number returned by the Geometry Dash servers.
 * @param raw The permission number from the Geometry Dash servers
 * @returns The {@link Permission} representing the given permission number
 * @internal
 */
const generatePermission = (raw) => ({
    raw: raw,
    pretty: PERMISSIONS[raw]
});
/** @internal */
const SOCIALMAP = {
    youtube: 'https://youtube.com/channel/',
    twitch: 'https://twitch.tv/',
    twitter: 'https://twitter.com/'
};
/**
 * Generates a {@link SocialURL} from a path and type returned by the Geometry Dash servers.
 * @param path The path from the Geometry Dash servers
 * @param type The social media platform from the Geometry Dash servers
 * @returns The {@link SocialURL} representing the given social media
 * @internal
 */
const generateSocial = (path, type) => ({
    path,
    fullURL: SOCIALMAP[type] + path
});
/**
 * A Geometry Dash player's cosmetics
 */
class UserCosmetics {
    /** @internal */
    constructor(
    /** @internal */
    _creator, 
    /** The player's raw cube number */
    cube, 
    /** The player's raw ship number */
    ship, 
    /** The player's raw ball number */
    ball, 
    /** The player's raw UFO number */
    ufo, 
    /** The player's raw wave number */
    wave, 
    /** The player's raw robot number */
    robot, 
    /** The player's raw glow number */
    glow, 
    /** The player's raw spider number */
    spider, explosion, 
    /** The colors the player uses */
    colors) {
        this._creator = _creator;
        this.cube = cube;
        this.ship = ship;
        this.ball = ball;
        this.ufo = ufo;
        this.wave = wave;
        this.robot = robot;
        this.glow = glow;
        this.spider = spider;
        this.colors = colors;
        if (!isNaN(explosion))
            this.explosion = explosion;
    }
    async renderIcon(type = 'cube', returnRaw = false) {
        const params = [
            ['form', type],
            ['icon', this[type].toString()],
            ['col1', this.colors.primary.raw.toString()],
            ['col2', this.colors.secondary.raw.toString()],
            ['glow', this.glow.toString()],
            ['noUser', '1']
        ]
            .map(([x, y]) => x + '=' + y)
            .join('&');
        const response = await this._creator._client.req(`https://gdbrowser.com/icon/gd.js?${params}`, {}, true);
        if (returnRaw)
            return response;
        return response.arrayBuffer();
    }
}
/**
 * A Geometry Dash player
 */
class User {
    /**
     * Constructs data about a Geometry Dash player
     * @param _creator The creator associated with this user
     * @param rawData The raw data returned from the Geometry Dash request for this user
     * @internal
     */
    constructor(
    /** @internal */
    _creator, rawData) {
        this._creator = _creator;
        const d = parse(rawData);
        this.username = d[1];
        this.id = +d[2];
        this.accountID = +d[16];
        this.stats = {
            stars: +d[3],
            diamonds: +d[46],
            demons: +d[4],
            rank: +d[30],
            coins: {
                normal: +d[13],
                user: +d[17]
            },
            cp: +d[8]
        };
        const socials = {};
        if (d[20])
            socials.youtube = generateSocial(d[20], 'youtube');
        if (d[44])
            socials.twitter = generateSocial(d[44], 'twitter');
        if (d[45])
            socials.twitch = generateSocial(d[45], 'twitch');
        this.socials = socials;
        this.cosmetics = new UserCosmetics(_creator, +d[21], +d[22], +d[23], +d[24], +d[25], +d[26], +d[28], +d[43], +d[47], {
            primary: userColor(+d[10]),
            secondary: userColor(+d[11])
        });
        this.permissions = generatePermission(+d[49]);
    }
    async getAccountComments(num) {
        let singleReturn = false;
        if (!num) {
            num = 1;
            singleReturn = true;
        }
        const numToGet = Math.ceil(num / 10);
        const comments = [];
        for (let page = 0; page < numToGet; page++) {
            const params = new GDRequestParams({
                accountID: this.accountID,
                page,
                total: 0
            });
            params.authorize('db');
            const data = await this._creator._client.req('/getGJAccountComments20.php', {
                method: 'POST',
                body: params
            });
            if (data === '-1')
                return singleReturn ? null : [];
            const split = data.slice(0, data.indexOf('#')).split('|');
            comments.push(...split.map(str => this instanceof LoggedInUser
                ? new LoggedInAccountComment(this, str)
                : new AccountComment(this, str)));
            if (split.length < 10)
                break;
        }
        return singleReturn ? comments[0] || null : comments.slice(0, num);
    }
    async getComments(byLikes = false, num) {
        let singleReturn = false;
        if (!num) {
            num = 1;
            singleReturn = true;
        }
        const params = new GDRequestParams({
            count: num,
            userID: this.id,
            mode: +byLikes,
            page: 0,
            total: 0
        });
        params.authorize('db');
        const data = await this._creator._client.req('/getGJCommentHistory.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return singleReturn ? null : [];
        const comments = data
            .slice(0, data.indexOf('#'))
            .split('|')
            .map(str => {
            const comment = str.slice(0, str.indexOf(':'));
            return this instanceof LoggedInUser
                ? new LoggedInLevelComment(this._creator, this, comment)
                : new LevelComment(this._creator, this, comment);
        });
        return singleReturn ? comments[0] : comments;
    }
    async getLevels(num) {
        return this._creator._client.levels.byCreator(this, {}, num);
    }
}
/**
 * Likes an arbitrary Geometry Dash object
 * @param id The ID of the object to like
 * @param special The special string associated with this like type
 * @param type The like type
 * @param shouldLike Whather to like or not
 * @param accountID The account ID from which to like
 * @param gjp The GJP of the account
 * @param client The client to make the request from
 * @returns Whether liking was successful
 * @internal
 */
const like = async (id, special, type, shouldLike, accountID, gjp, client) => {
    const rs = genRS();
    const like = +shouldLike;
    const chk = encrypt(sha1('' + special + id + like + type + rs + accountID + udid + uuid + likeSalt), likeKey);
    const params = new GDRequestParams({
        accountID,
        gjp,
        type,
        special,
        itemID: id,
        like,
        udid,
        uuid,
        rs,
        chk
    });
    params.authorize('db');
    return ((await client.req('/likeGJItem211.php', {
        method: 'POST',
        body: params
    })) === '1');
};
/**
 * A logged-in Geometry Dash player
 */
class LoggedInUser extends User {
    constructor(_creator, rawData, 
    /** @internal */
    _creds) {
        super(_creator, rawData);
        this._creds = _creds;
    }
    /**
     * Post a comment to this account's page
     * @param msg The message to post
     * @returns The comment that was just created (may not be 100% accurate); null if it failed
     * @async
     */
    async postAccountComment(msg) {
        const comment = gdEncodeBase64(msg);
        const params = new GDRequestParams({
            ...this._creds,
            comment
        });
        params.authorize('db');
        const data = await this._creator._client.req('/uploadGJAccComment20.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return null;
        return new LoggedInAccountComment(this, `2~${comment}~9~0 seconds~6~${data}~4~0~7~0`); // best we can do
    }
    /**
     * Post a comment to a level
     * @param level The level to post the comment on
     * @param msg The message to post
     * @param percent The percentage to post with the comment. This can be any integer (even above 100)
     * @returns The comment that was just created (may not be 100% accurate); null if it failed
     * @async
     */
    async postComment(level, msg, percent) {
        if (level instanceof SearchedLevel)
            level = level.id;
        if (!percent)
            percent = 0;
        const comment = gdEncodeBase64(msg);
        const chk = encrypt(sha1(this._creds.userName + comment + level + percent + '0' + commentSalt), commentKey);
        const params = new GDRequestParams({
            ...this._creds,
            levelID: level,
            comment,
            percent,
            chk
        });
        params.authorize('db');
        const data = await this._creator._client.req('/uploadGJComment21.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return null;
        return new LoggedInLevelComment(this._creator, this, `2~${comment}~9~0 seconds~6~${data}~4~0~7~0~10~${percent}`);
    }
    /**
     * Deletes an account comment from the server
     * @param commentID The comment (or its ID) to delete
     * @async
     */
    async deleteAccountComment(commentID) {
        if (commentID instanceof AccountComment) {
            if (commentID.author.accountID !== this.accountID)
                return false;
            commentID = commentID.id;
        }
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            commentID
        });
        params.authorize('db');
        return ((await this._creator._client.req('/deleteGJAccComment20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    async deleteComment(commentID, levelID) {
        if (commentID instanceof LevelComment) {
            if (commentID.author.accountID !== this.accountID)
                return false;
            levelID = commentID.levelID;
            commentID = commentID.id;
        }
        else if (levelID instanceof SearchedLevel) {
            levelID = levelID.id;
        }
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            commentID,
            levelID
        });
        params.authorize('db');
        return ((await this._creator._client.req('/deleteGJComment20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    /**
     * Send a friend request to another player
     * @param id The account ID, username, user, or searched user to send a friend request to
     * @param msg The message to send with the friend request
     * @returns Whether the friend request sending was successful
     * @async
     */
    async sendFriendRequest(id, msg = '') {
        const toAccountID = await convertToAccountID(this._creator, id);
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            toAccountID,
            comment: gdEncodeBase64(msg)
        });
        params.authorize('db');
        return ((await this._creator._client.req('/uploadFriendRequest20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    /**
     * Sends a message to a friend
     * @param id The account ID, username, user, or searched user to message. Must be a friend of this account.
     * @param subject The subject of the message to send
     * @param body The body of the message to send
     * @returns Whether sending the message was successful
     * @async
     */
    async sendMessage(id, subject, body) {
        const toAccountID = await convertToAccountID(this._creator, id);
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            toAccountID,
            subject: gdEncodeBase64(subject),
            body: gdEncodeBase64(body)
        });
        params.authorize('db');
        return ((await this._creator._client.req('/uploadGJMessage20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    async getFriendRequests(num = 10, outgoing = false) {
        const numToGet = Math.ceil(num / 10);
        const reqs = [];
        for (let page = 0; page < numToGet; page++) {
            const params = new GDRequestParams({
                accountID: this.accountID,
                gjp: this._creds.gjp,
                page,
                getSent: +outgoing,
                total: 0
            });
            params.authorize('db');
            const data = await this._creator._client.req('/getGJFriendRequests20.php', {
                method: 'POST',
                body: params
            });
            if (['-1', '-2'].includes(data))
                return reqs;
            const split = data.slice(0, data.indexOf('#')).split('|');
            reqs.push(...split.map(str => outgoing
                ? new OutgoingFriendRequest(this, this._creator, str)
                : new IncomingFriendRequest(this, this._creator, str)));
            if (split.length < 10)
                break;
        }
        return reqs.slice(0, num);
    }
    async getMessages(num = 10, outgoing = false) {
        const numToGet = Math.ceil(num / 10);
        const msgs = [];
        for (let page = 0; page < numToGet; page++) {
            const params = new GDRequestParams({
                accountID: this.accountID,
                gjp: this._creds.gjp,
                page,
                getSent: +outgoing,
                total: 0
            });
            params.authorize('db');
            const data = await this._creator._client.req('/getGJMessages20.php', {
                method: 'POST',
                body: params
            });
            if (['-1', '-2'].includes(data))
                return msgs;
            const split = data.slice(0, data.indexOf('#')).split('|');
            msgs.push(...split.map(str => outgoing ? new SearchedMessage(this, str) : new SearchedMessage(this, str)));
            if (split.length < 10)
                break;
        }
        return msgs.slice(0, num);
    }
    async getFullMessage(messageID, outgoing) {
        if (messageID instanceof SearchedMessage) {
            if ((messageID.outgoing ? messageID.from : messageID.to).accountID !== this.accountID)
                return null;
            outgoing = messageID.outgoing;
            messageID = messageID.id;
        }
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            messageID,
            isSender: +outgoing
        });
        params.authorize('db');
        const data = await this._creator._client.req('/downloadGJMessage20.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return null;
        return new Message(this, data);
    }
    async deleteMessage(messageID, outgoing) {
        if (messageID instanceof SearchedMessage) {
            if ((messageID.outgoing ? messageID.from : messageID.to).accountID !== this.accountID)
                return false;
            outgoing = messageID.outgoing;
            messageID = messageID.id;
        }
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            messageID,
            isSender: +outgoing
        });
        params.authorize('db');
        return ((await this._creator._client.req('/deleteGJMessages20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    /**
     * Mark a friend request as read
     * @param fr The friend request to mark
     * @returns Whether marking as read was successful or not
     * @async
     */
    async markFriendRequestAsRead(fr) {
        if (fr.to.accountID !== this.accountID)
            return false;
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            requestID: fr.id
        });
        params.authorize('db');
        return (fr.read =
            (await this._creator._client.req('/readGJFriendRequest20.php', {
                method: 'POST',
                body: params
            })) === '1');
    }
    /**
     * Accepts a friend request
     * @param fr The friend request to accept
     * @returns Whether accepting the friend request was successful
     * @async
     */
    async acceptFriendRequest(fr) {
        if (fr.to.accountID !== this.accountID)
            return false;
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            requestID: fr.id,
            targetAccountID: fr.from.accountID
        });
        params.authorize('db');
        return ((await this._creator._client.req('/acceptGJFriendRequest20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    /**
     * Rejects a friend request, deleting it from the server
     * @param fr The friend request to reject
     * @returns Whether the rejection was succesful
     * @async
     */
    async rejectFriendRequest(fr) {
        if (fr.to.accountID !== this.accountID)
            return false;
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            targetAccountID: fr.from.accountID,
            isSender: 0
        });
        params.authorize('db');
        return ((await this._creator._client.req('/deleteGJFriendRequests20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    /**
     * Unfriends another player.
     * @param id The account ID, username, user, or searched user to message. Must be a friend of this account.
     * @returns Whether the unfriending was successful
     * @async
     */
    async unfriend(id) {
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            targetAccountID: await convertToAccountID(this._creator, id)
        });
        params.authorize('db');
        return ((await this._creator._client.req('/removeGJFriend20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    /**
     * Cancels a friend request, deleting it from the server
     * @param fr The friend request to cancel
     * @returns Whether the cancellation was succesful
     * @async
     */
    async cancelFriendRequest(fr) {
        if (fr.from.accountID !== this.accountID)
            return false;
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            targetAccountID: fr.to.accountID,
            isSender: 1
        });
        params.authorize('db');
        return ((await this._creator._client.req('/deleteGJFriendRequests20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    /**
     * Block a user
     * @param user The user to block
     * @returns Whether the blocking succeeded
     * @async
     */
    async block(user) {
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            targetAccountID: await convertToAccountID(this._creator, user)
        });
        params.authorize('db');
        return ((await this._creator._client.req('/blockGJUser20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    /**
     * Unblock a user
     * @param user The user to unblock
     * @returns Whether the unblocking succeeded
     * @async
     */
    async unblock(user) {
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            targetAccountID: await convertToAccountID(this._creator, user)
        });
        params.authorize('db');
        return ((await this._creator._client.req('/unblockGJUser20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
    /**
     * Finds all friends of this player
     * @returns An array of the player's friends
     * @async
     */
    async getFriends() {
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            type: 0
        });
        params.authorize('db');
        const data = await this._creator._client.req('/getGJUserList20.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return [];
        return data.split('|').map(str => new StatlessSearchedUser(this._creator, parse(str)));
    }
    /**
     * Finds the users that have been blocked by this player
     * @returns An array of blocked users
     * @async
     */
    async getBlocked() {
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            type: 1
        });
        params.authorize('db');
        const data = await this._creator._client.req('/getGJUserList20.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return [];
        return data.split('|').map(str => new StatlessSearchedUser(this._creator, parse(str)));
    }
    /**
     * Gets the friends leaderboard
     * @returns The leaderboard, with position being index + 1
     * @async
     */
    async getFriendsLeaderboard() {
        const params = new GDRequestParams({
            accountID: this.accountID,
            gjp: this._creds.gjp,
            type: 'friends',
            page: 0,
            total: 0
        });
        params.authorize('db');
        const data = await this._creator._client.req('/getGJScores20.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return [];
        const leaderboard = data
            .slice(0, data.indexOf('#'))
            .split('|')
            .map(str => new SearchedUser(this._creator, str));
        const me = leaderboard.pop();
        let insertIndex = leaderboard.findIndex(val => val.stats.stars <= me.stats.stars);
        if (insertIndex === -1)
            insertIndex = leaderboard.length;
        leaderboard.splice(insertIndex, 0, me);
        return leaderboard;
    }
    /**
     * Likes a Geometry Dash entity
     * @param id The object to like. This can be a level, account comment, or level comment
     * @returns Whether the liking succeeded
     * @async
     */
    async like(id) {
        return id instanceof SearchedLevel
            ? this.likeLevel(id)
            : id instanceof LevelComment
                ? this.likeComment(id)
                : id instanceof AccountComment
                    ? this.likeAccountComment(id)
                    : false;
    }
    /**
     * Dislikes a Geometry Dash entity
     * @param id The object to dislike. This can be a level, account comment, or level comment
     * @returns Whether the disliking succeeded
     * @async
     */
    async dislike(id) {
        return id instanceof SearchedLevel
            ? this.dislikeLevel(id)
            : id instanceof LevelComment
                ? this.dislikeComment(id)
                : id instanceof AccountComment
                    ? this.dislikeAccountComment(id)
                    : false;
    }
    /**
     * Likes a level
     * @param id The ID of the level to like (or the level itself)
     * @returns Whether the liking succeeded
     * @async
     */
    async likeLevel(id) {
        if (id instanceof SearchedLevel) {
            id = id.id;
        }
        return await like(id, 0, 1, true, this.accountID, this._creds.gjp, this._creator._client);
    }
    /**
     * Dislikes a level
     * @param id The ID of the level to dislike (or the level itself)
     * @returns Whether the disliking succeeded
     * @async
     */
    async dislikeLevel(id) {
        if (id instanceof SearchedLevel) {
            id = id.id;
        }
        return await like(id, 0, 1, false, this.accountID, this._creds.gjp, this._creator._client);
    }
    async likeComment(id, levelID) {
        if (id instanceof LevelComment) {
            if (id.author.accountID === this.accountID)
                return false;
            levelID = id.levelID;
            id = id.id;
        }
        else if (levelID instanceof SearchedLevel)
            levelID = levelID.id;
        return await like(id, levelID, 2, true, this.accountID, this._creds.gjp, this._creator._client);
    }
    async dislikeComment(id, levelID) {
        if (id instanceof LevelComment) {
            if (id.author.accountID === this.accountID)
                return false;
            levelID = id.levelID;
            id = id.id;
        }
        else if (levelID instanceof SearchedLevel)
            levelID = levelID.id;
        return await like(id, levelID, 2, false, this.accountID, this._creds.gjp, this._creator._client);
    }
    async likeAccountComment(id, accountID) {
        if (id instanceof AccountComment) {
            accountID = id.author.accountID;
            if (accountID === this.accountID)
                return false;
            id = id.id;
        }
        else if (accountID instanceof StatlessSearchedUser || accountID instanceof User)
            accountID = accountID.accountID;
        return await like(id, accountID, 3, true, this.accountID, this._creds.gjp, this._creator._client);
    }
    async dislikeAccountComment(id, accountID) {
        if (id instanceof AccountComment) {
            accountID = id.author.accountID;
            if (accountID === this.accountID)
                return false;
            id = id.id;
        }
        else if (accountID instanceof StatlessSearchedUser || accountID instanceof User)
            accountID = accountID.accountID;
        return await like(id, accountID, 3, false, this.accountID, this._creds.gjp, this._creator._client);
    }
    async updateLevelDescription(levelID, desc) {
        if (levelID instanceof SearchedLevel) {
            if (levelID.creator.id !== this.id) {
                return false;
            }
            levelID = levelID.id;
        }
        const params = new GDRequestParams({
            ...this._creds,
            levelID,
            levelDesc: gdEncodeBase64(desc)
        });
        params.authorize('db');
        return ((await this._creator._client.req('/updateGJDesc20.php', {
            method: 'POST',
            body: params
        })) === '1');
    }
}
/** @internal */
const ICONTYPEMAP = ['cube', 'ship', 'ball', 'ufo', 'wave', 'robot', 'spider'];
/**
 * Cosmetics of a user found by a search
 */
class SearchedUserCosmetics {
    /**
     * Creates new info about a searched user's cosmetics
     * @param icon The number of the icon
     * @param iconType The type of the icon
     * @param colors The colors the player uses
     */
    constructor(
    /** @internal */
    _creator, icon, iconType, colors) {
        this._creator = _creator;
        this.icon = {
            val: icon,
            type: iconType
        };
        this.colors = colors;
    }
    async renderIcon(returnRaw = false) {
        return await UserCosmetics.prototype.renderIcon.call({
            glow: 0,
            [this.icon.type]: this.icon.val,
            _creator: this._creator,
            colors: this.colors
        }, this.icon.type, returnRaw);
    }
}
/**
 * Details about a Geometry Dash player returned from a search, without any stats
 */
class StatlessSearchedUser {
    /**
     * Creates a searched user
     * @param _creator The searched user's creator
     * @param rawData The raw data to parse
     */
    constructor(
    /** @internal */
    _creator, rawData) {
        this._creator = _creator;
        const d = typeof rawData == 'string' ? parse(rawData, '~') : rawData;
        this.username = d[1];
        const id = +d[2];
        if (id)
            this.id = id;
        this.accountID = +d[16];
        this.cosmetics = new SearchedUserCosmetics(_creator, +d[9], ICONTYPEMAP[+d[14]], {
            primary: userColor(+d[10]),
            secondary: userColor(+d[11])
        });
    }
    async getAccountComments(num) {
        let singleReturn = false;
        if (!num) {
            num = 1;
            singleReturn = true;
        }
        const numToGet = Math.ceil(num / 10);
        const comments = [];
        for (let page = 0; page < numToGet; page++) {
            const params = new GDRequestParams({
                accountID: this.accountID,
                page,
                total: 0
            });
            params.authorize('db');
            const data = await this._creator._client.req('/getGJAccountComments20.php', {
                method: 'POST',
                body: params
            });
            if (data === '-1')
                return singleReturn ? null : [];
            const split = data.slice(0, data.indexOf('#')).split('|');
            comments.push(...split.map(str => new AccountComment(this, str)));
            if (split.length < 10)
                break;
        }
        return singleReturn ? comments[0] || null : comments.slice(0, num);
    }
    async getComments(byLikes = false, num) {
        let singleReturn = false;
        if (!num) {
            num = 1;
            singleReturn = true;
        }
        const params = new GDRequestParams({
            count: num,
            userID: this.id,
            mode: +byLikes,
            page: 0,
            total: 0
        });
        params.authorize('db');
        const data = await this._creator._client.req('/getGJCommentHistory.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return singleReturn ? null : [];
        const comments = data
            .slice(0, data.indexOf('#'))
            .split('|')
            .map(str => {
            const comment = str.slice(0, str.indexOf(':'));
            return new LevelComment(this._creator, this, comment);
        });
        return singleReturn ? comments[0] : comments;
    }
    async getLevels(num) {
        return this._creator._client.levels.byCreator(this, {}, num);
    }
    /**
     * Converts the searched user into a full user
     * @returns The full data about the user
     * @async
     */
    async resolve() {
        return await this._creator.get(this.accountID);
    }
}
/**
 * Details about a Geometry Dash player returned from a search
 */
class SearchedUser extends StatlessSearchedUser {
    /**
     * Creates a searched user with stats
     * @param _creator The searched user's raw data
     * @param rawData The raw data to parse
     */
    constructor(_creator, rawData) {
        const d = parse(rawData); // Inefficient, yes, but easier
        super(_creator, d);
        this.stats = {
            stars: +d[3],
            demons: +d[4],
            coins: {
                normal: +d[13],
                user: +d[17]
            },
            cp: +d[8]
        };
    }
}
/**
 * A creator for Geometry Dash players
 */
class UserCreator extends Creator {
    /**
     * Find a player by accountID or username
     * @param id The account ID or username of the player to get
     * @returns The player with the provided account ID or username
     * @async
     */
    async get(id) {
        switch (typeof id) {
            case 'number':
                return await this.getByAccountID(id);
            case 'string':
                return await this.getByUsername(id);
            case 'object': {
                if (id instanceof StatlessSearchedUser || id instanceof User)
                    return await this.getByAccountID(id.accountID);
            }
            default:
                return null;
        }
    }
    /**
     * Gets the information about a player using its account ID
     * @param id The account ID of the player to get
     * @returns The player with the provided account ID
     * @async
     */
    async getByAccountID(id) {
        const params = new GDRequestParams({
            targetAccountID: id
        });
        params.authorize('db');
        const data = await this._client.req('/getGJUserInfo20.php', { method: 'POST', body: params });
        if (data === '-1')
            return null;
        return new User(this, data);
    }
    async search(str, num) {
        let singleReturn = false;
        if (!num) {
            num = 1;
            singleReturn = true;
        }
        const numToGet = Math.ceil(num / 10);
        const searchedUsers = [];
        for (let page = 0; page < numToGet; page++) {
            const params = new GDRequestParams({
                str,
                page,
                total: 0
            });
            params.authorize('db');
            const data = await this._client.req('/getGJUsers20.php', { method: 'POST', body: params });
            if (data === '-1')
                return singleReturn ? null : searchedUsers;
            const split = data.slice(0, data.indexOf('#')).split('|');
            searchedUsers.push(...split.map(str => new SearchedUser(this, str)));
            if (split.length < 10)
                break;
        }
        return singleReturn ? searchedUsers[0] || null : searchedUsers.slice(0, num);
    }
    async getByUsername(str, resolve = true) {
        const possibleUser = await this.search(str);
        if (possibleUser && possibleUser.username.toLowerCase() === str.toLowerCase())
            return resolve ? possibleUser.resolve() : possibleUser;
        return null;
    }
    async getLeaderboard(creators = false, num) {
        let singleReturn = false;
        if (!num) {
            num = 1;
            singleReturn = true;
        }
        const params = new GDRequestParams({
            count: num,
            type: creators ? 'creators' : 'top',
            page: 0,
            total: 0
        });
        params.authorize('db');
        const data = await this._client.req('/getGJScores20.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            return singleReturn ? null : [];
        const leaders = data
            .slice(0, data.indexOf('#'))
            .split('|')
            .map(str => new SearchedUser(this, str));
        return singleReturn ? leaders[0] : leaders.slice(0, num);
    }
    /**
     * Log in to a Geometry Dash account
     * @param userCreds The username and password to log in with
     * @throws {TypeError} if credentials are invalid
     * @returns The logged in user associated with the provided credentials
     * @async
     */
    async login(userCreds) {
        const params = new GDRequestParams();
        params.insertParams({
            userName: userCreds.username,
            password: userCreds.password,
            udid
        });
        params.authorize('account');
        const data = await this._client.req('/accounts/loginGJAccount.php', {
            method: 'POST',
            body: params
        });
        if (data === '-1')
            throw new TypeError('could not log in because the credentials were invalid');
        // TODO: What to do with userID (index 1)?
        const [accountIDStr] = data.split(',');
        return this.authorize({
            userName: userCreds.username,
            accountID: +accountIDStr,
            gjp: encrypt(userCreds.password, accountKey)
        });
    }
    /**
     * Log in to a Geometry Dash account using preprocessed credentials
     * @param creds The credentials to log in with
     * @throws {TypeError} if credentials are invalid
     * @returns The logged in user associated with the provided credentials
     * @async
     */
    async authorize(creds) {
        const infoParams = new GDRequestParams({
            targetAccountID: creds.accountID
        });
        infoParams.authorize('db');
        const infoData = await this._client.req('/getGJUserInfo20.php', {
            method: 'POST',
            body: infoParams
        });
        if (infoData === '-1')
            throw new TypeError('could not log in because the credentials were invalid');
        return new LoggedInUser(this, infoData, creds);
    }
}
export { User, LoggedInUser, SearchedUser, StatlessSearchedUser, UserCreator, Comment, LevelComment, AccountComment, LoggedInAccountComment, LoggedInLevelComment, FriendRequest, IncomingFriendRequest, OutgoingFriendRequest, SearchedMessage, Message, UserCosmetics, SearchedUserCosmetics };
