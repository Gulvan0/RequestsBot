/**
 * User utilities
 * @packageDocumentation
 */
import Creator from './entityCreator';
import { SearchedLevel, Level, LoggedInSearchedLevel } from './level';
import { ParsedData, GDDate } from '../util';
/**
 * Types that can be converted to an account ID
 */
declare type ConvertibleToAccountID = number | string | User | StatlessSearchedUser;
/**
 * A comment made by a Geometry Dash player
 */
declare abstract class Comment {
    /** The text in the comment */
    text: string;
    /** The time when the comment was created */
    createdAt: GDDate;
    /** The ID of the comment */
    id: number;
    /** The number of likes on the comment */
    likes: number;
    /** Whether or not the comment has been marked as spam */
    isSpam: boolean;
    /** The comment's author */
    author: StatlessSearchedUser | User;
}
declare class AccountComment<T extends User | StatlessSearchedUser> extends Comment {
    author: T;
}
declare class LoggedInAccountComment extends AccountComment<LoggedInUser> {
    /**
     * Deletes the comment from the Geometry Dash servers
     * @returns A promise that resolves with a boolean of whether deletion was successful
     * @async
     */
    delete(): Promise<boolean>;
}
declare class LevelComment<T extends User | StatlessSearchedUser> extends Comment {
    author: T;
    /** The ID of the level this comment is from */
    levelID: number;
    /** The percentage the user reached on the level. Only present if the commenter opted to show percentage with their comment. */
    percent?: number;
    /**
     * Gets the level associated with this comment
     * @param resolve Whether or not to resolve the search into the full level
     * @returns The level or searched level this comment belongs to
     * @async
     */
    getLevel(resolve?: false): Promise<SearchedLevel>;
    /**
     * Gets the level associated with this comment
     * @param resolve Whether or not to resolve the search into the full level
     * @returns The level or searched level this comment belongs to
     * @async
     */
    getLevel(resolve: true): Promise<Level>;
}
declare class LoggedInLevelComment extends LevelComment<LoggedInUser> {
    /**
     * Deletes this comment from the servers
     * @returns Whether the comment deletion was successful
     * @async
     */
    delete(): Promise<boolean>;
}
/**
 * A friend request
 */
declare abstract class FriendRequest<O extends boolean> {
    /** The friend request ID */
    id: number;
    /** The message with the friend request */
    msg: string;
    /** Whether the friend request has been read yet */
    read: boolean;
    /** Who the friend request is from */
    from: O extends true ? LoggedInUser : StatlessSearchedUser;
    /** Who the friend request is to */
    to: O extends true ? StatlessSearchedUser : LoggedInUser;
}
/**
 * An outgoing friend request
 */
declare class OutgoingFriendRequest extends FriendRequest<true> {
    /**
     * Creates info about an outgoing friend request
     * @param account The account that sent the friend request
     * @param creator The creator of the user the account belongs to
     * @param rawData The raw data to parse
     */
    constructor(account: LoggedInUser, creator: UserCreator, rawData: string);
    /**
     * Cancels a friend request, deleting it from the server
     * @returns Whether the cancellation was successful
     * @async
     */
    cancel(): Promise<boolean>;
}
declare class IncomingFriendRequest extends FriendRequest<false> {
    /**
     * Mark a friend request as read
     * @returns Whether marking as read was successful
     * @async
     */
    markAsRead(): Promise<boolean>;
    /**
     * Accept a friend request
     * @returns Whether accepting the friend request was successful
     * @async
     */
    accept(): Promise<boolean>;
    /**
     * Rejects a friend request, deleting it from the server
     * @returns Whether the rejection was successful
     * @async
     */
    reject(): Promise<boolean>;
}
declare type MessageUser = {
    /** The player's username */
    username: string;
    /** The player's user ID */
    id: number;
    /** The player's account ID */
    accountID: number;
};
declare class SearchedMessage<O extends boolean> {
    /** The message's ID */
    id: number;
    /** The message's subject */
    subject: string;
    /** The message's sender */
    from: O extends true ? LoggedInUser : MessageUser;
    /** The message's recipient */
    to: O extends true ? MessageUser : LoggedInUser;
    /** When the message was sent */
    sentAt: GDDate;
    /** Whether the message has been read */
    read: boolean;
    /** Whether the message is outgoing or not */
    outgoing: O;
    /**
     * Deletes this message from the server
     * @returns Whether the message deletion was successful
     * @async
     */
    delete(): Promise<boolean>;
    /**
     * Resolves the message into a full message
     * @returns The full message from this searched message
     * @async
     */
    resolve(): Promise<Message<O>>;
}
declare class Message<O extends boolean> extends SearchedMessage<O> {
    /** The message's body */
    body: string;
}
/**
 * A color used by a Geometry Dash player.
 */
declare type GDColor = {
    /**
     * The raw color number, as returned by the server
     */
    raw: number;
    /**
     * The color in hexadecimal notation
     */
    parsed: string;
};
declare type PermissionLevel = 'User' | 'Moderator' | 'Elder Moderator';
/**
 * A permission level for a Geometry Dash player.
 */
declare type Permission = {
    /** The raw permission number, as returned by the server. 0 = user, 1 = mod, 2 = elder mod. */
    raw: 0 | 1 | 2;
    /** A prettified string for the permission level. One of "User", "Moderator" or "Elder Moderator" */
    pretty: PermissionLevel;
};
/**
 * A social media platform that a Geometry Dash player uses
 */
declare type SocialURL = {
    /** The path to the player's social media from the platform's base URL */
    path: string;
    /** The full URL path to the player's social media */
    fullURL: string;
};
/**
 * An icon type
 */
declare type IconCosmetic = 'cube' | 'ship' | 'ball' | 'ufo' | 'wave' | 'spider' | 'robot';
/**
 * The colors in a Geometry Dash user's profile
 */
declare type Colors = {
    primary: GDColor;
    secondary: GDColor;
};
/**
 * A Geometry Dash player's cosmetics
 */
declare class UserCosmetics {
    /** The player's raw cube number */
    cube: number;
    /** The player's raw ship number */
    ship: number;
    /** The player's raw ball number */
    ball: number;
    /** The player's raw UFO number */
    ufo: number;
    /** The player's raw wave number */
    wave: number;
    /** The player's raw robot number */
    robot: number;
    /** The player's raw glow number */
    glow: number;
    /** The player's raw spider number */
    spider: number;
    /** The colors the player uses */
    colors: Colors;
    /** The player's raw explosion number */
    explosion?: number;
    /**
     * Renders one of the user's icons as an image using the GDBrowser API
     * @param type The type of icon to render
     * @param returnRaw Whether to return a raw Response or an ArrayBuffer
     * @returns The Response or ArrayBuffer containing the image
     * @async
     */
    renderIcon(type: IconCosmetic, returnRaw?: false): Promise<ArrayBuffer>;
    renderIcon(type: IconCosmetic, returnRaw: true): Promise<Response>;
}
/**
 * The social media platforms a Geometry Dash player uses
 */
declare type Socials = {
    /** The player's YouTube channel */
    youtube?: SocialURL;
    /** The player's Twitter account */
    twitter?: SocialURL;
    /** The player's Twitch channel */
    twitch?: SocialURL;
};
/**
 * A Geometry Dash player
 */
declare class User {
    /** The player's username  */
    username: string;
    /** The player's user ID */
    id: number;
    /** The player's account ID */
    accountID: number;
    /** The player's stats */
    stats: {
        /** The number of stars the player has collected */
        stars: number;
        /** The number of diamonds the player has collected */
        diamonds: number;
        /** The number of demons the player has beaten */
        demons: number;
        /** The global rank of the player */
        rank: number;
        /** The coins the player has collected */
        coins: {
            /** The number of coins in the single-player mode (gold coins) the player has collected */
            normal: number;
            /** The number of coins in user-created levels (silver coins) the player has collected */
            user: number;
        };
        /** The number of creator points the player has earned */
        cp: number;
    };
    /** The player's social media profiles */
    socials: Readonly<Socials>;
    /** The player's cosmetics */
    cosmetics: UserCosmetics;
    /** The player's permissions */
    permissions: Permission;
    /**
     * Get the most recent comment posted to this account's page
     * @returns The most recent comment
     * @async
     */
    getAccountComments(): Promise<AccountComment<this>>;
    /**
     * Get the comments posted to this account's page
     * @param num The maximum number of comments to get
     * @returns An array of this user's profile comments
     * @async
     */
    getAccountComments(num: number): Promise<AccountComment<this>[]>;
    /**
     * Gets the most recent or most liked level comment by the user
     * @param byLikes Whether to sort by likes or not
     * @returns The most recent or most liked comment made by this user
     * @async
     */
    getComments(byLikes?: boolean): Promise<LevelComment<this>>;
    /**
     * Gets the most recent or most liked level comments by the user
     * @param byLikes Whether to sort by likes or not
     * @param num The number of comments to get
     * @returns An array of the most recent or most liked comments made by this user
     * @async
     */
    getComments(byLikes: boolean, num: number): Promise<LevelComment<this>[]>;
    /**
     * Gets the most recent level by the user
     * @returns The most recent level made by this user
     * @async
     */
    getLevels(): Promise<this extends LoggedInUser ? LoggedInSearchedLevel : SearchedLevel>;
    /**
     * Gets the most recentlevels by the user
     * @param num The number of levels to get
     * @returns An array of the most recent levels made by this user
     * @async
     */
    getLevels(num: number): Promise<(this extends LoggedInUser ? LoggedInSearchedLevel : SearchedLevel)[]>;
}
/**
 * Credentials to use in requests to Geometry Dash servers
 */
export declare type Credentials = {
    /** The player's username */
    userName: string;
    /** The player's account ID */
    accountID: number;
    /** The player's password, XOR-encrypted */
    gjp: string;
};
/**
 * A logged-in Geometry Dash player
 */
declare class LoggedInUser extends User {
    constructor(_creator: UserCreator, rawData: string, 
    /** @internal */
    _creds: Credentials);
    /**
     * Post a comment to this account's page
     * @param msg The message to post
     * @returns The comment that was just created (may not be 100% accurate); null if it failed
     * @async
     */
    postAccountComment(msg: string): Promise<LoggedInAccountComment>;
    /**
     * Post a comment to a level
     * @param level The level to post the comment on
     * @param msg The message to post
     * @param percent The percentage to post with the comment. This can be any integer (even above 100)
     * @returns The comment that was just created (may not be 100% accurate); null if it failed
     * @async
     */
    postComment(level: SearchedLevel | number, msg: string, percent?: number): Promise<LoggedInLevelComment>;
    /**
     * Deletes an account comment from the server
     * @param commentID The comment (or its ID) to delete
     * @async
     */
    deleteAccountComment(commentID: number | AccountComment<User>): Promise<boolean>;
    /**
     * Deletes a comment from the server
     * @param commentID The comment ID to delete
     * @param levelID The level ID where the comment was posted
     * @returns Whether the comment deletion was successful
     * @async
     */
    deleteComment(commentID: number, levelID: number | SearchedLevel): Promise<boolean>;
    /**
     * Deletes a comment from the server
     * @param commentID The comment object to delete
     * @returns Whether the comment deletion was successful
     * @async
     */
    deleteComment(commentID: LevelComment<User>): Promise<boolean>;
    /**
     * Send a friend request to another player
     * @param id The account ID, username, user, or searched user to send a friend request to
     * @param msg The message to send with the friend request
     * @returns Whether the friend request sending was successful
     * @async
     */
    sendFriendRequest(id: ConvertibleToAccountID, msg?: string): Promise<boolean>;
    /**
     * Sends a message to a friend
     * @param id The account ID, username, user, or searched user to message. Must be a friend of this account.
     * @param subject The subject of the message to send
     * @param body The body of the message to send
     * @returns Whether sending the message was successful
     * @async
     */
    sendMessage(id: ConvertibleToAccountID, subject: string, body: string): Promise<boolean>;
    /**
     * Gets friend requests
     * @param num The number of friend requests to get. Default 10.
     * @param outgoing Whether to get outgoing or incoming friend requests. Defaults to incoming.
     * @returns The array of friend requests based on the provided parameters
     * @async
     */
    getFriendRequests(num?: number, outgoing?: false): Promise<IncomingFriendRequest[]>;
    /**
     * Gets friend requests
     * @param num The number of friend requests to get. Default 10.
     * @param outgoing Whether to get outgoing or incoming friend requests. Defaults to incoming.
     * @returns The array of friend requests based on the provided parameters
     * @async
     */
    getFriendRequests(num: number, outgoing: true): Promise<OutgoingFriendRequest[]>;
    /**
     * Gets messages sent to or from this user
     * @param num The number of messages to get. Defaults to 10.
     * @param outgoing Whether to get outgoing or incoming messages. Defaults to incoming.
     * @returns An array of incoming or outgoing messages
     * @async
     */
    getMessages(num?: number, outgoing?: false): Promise<SearchedMessage<false>[]>;
    /**
     * Gets messages sent to or from this user
     * @param num The number of messages to get. Defaults to 10.
     * @param outgoing Whether to get outgoing or incoming messages. Defaults to incoming.
     * @returns An array of incoming or outgoing messages
     * @async
     */
    getMessages(num: number, outgoing: true): Promise<SearchedMessage<true>[]>;
    /**
     * Gets the full message from a searched message
     * @param messageID The message object to resolve
     * @returns The full message, including the body
     * @async
     */
    getFullMessage<T extends boolean>(messageID: SearchedMessage<T>): Promise<Message<T>>;
    /**
     * Gets the full message from a searched message
     * @param messageID The message ID to resolve
     * @param outgoing Whether the message is outgoing or not
     * @returns The full message, including the body
     * @async
     */
    getFullMessage<T extends boolean>(messageID: number, outgoing: boolean): Promise<Message<T>>;
    /**
     * Deletes a message from the servers
     * @param message The message object to delete
     * @returns Whether the message deletion was successful
     * @async
     */
    deleteMessage(messageID: SearchedMessage<boolean>): Promise<boolean>;
    /**
     * Deletes a message from the servers
     * @param message The message ID to delete
     * @param outgoing Whether the message is outgoing or not
     * @returns Whether the message deletion was successful
     * @async
     */
    deleteMessage(messageID: number, outgoing: boolean): Promise<boolean>;
    /**
     * Mark a friend request as read
     * @param fr The friend request to mark
     * @returns Whether marking as read was successful or not
     * @async
     */
    markFriendRequestAsRead(fr: IncomingFriendRequest): Promise<boolean>;
    /**
     * Accepts a friend request
     * @param fr The friend request to accept
     * @returns Whether accepting the friend request was successful
     * @async
     */
    acceptFriendRequest(fr: IncomingFriendRequest): Promise<boolean>;
    /**
     * Rejects a friend request, deleting it from the server
     * @param fr The friend request to reject
     * @returns Whether the rejection was succesful
     * @async
     */
    rejectFriendRequest(fr: IncomingFriendRequest): Promise<boolean>;
    /**
     * Unfriends another player.
     * @param id The account ID, username, user, or searched user to message. Must be a friend of this account.
     * @returns Whether the unfriending was successful
     * @async
     */
    unfriend(id: ConvertibleToAccountID): Promise<boolean>;
    /**
     * Cancels a friend request, deleting it from the server
     * @param fr The friend request to cancel
     * @returns Whether the cancellation was succesful
     * @async
     */
    cancelFriendRequest(fr: OutgoingFriendRequest): Promise<boolean>;
    /**
     * Block a user
     * @param user The user to block
     * @returns Whether the blocking succeeded
     * @async
     */
    block(user: ConvertibleToAccountID): Promise<boolean>;
    /**
     * Unblock a user
     * @param user The user to unblock
     * @returns Whether the unblocking succeeded
     * @async
     */
    unblock(user: ConvertibleToAccountID): Promise<boolean>;
    /**
     * Finds all friends of this player
     * @returns An array of the player's friends
     * @async
     */
    getFriends(): Promise<StatlessSearchedUser[]>;
    /**
     * Finds the users that have been blocked by this player
     * @returns An array of blocked users
     * @async
     */
    getBlocked(): Promise<StatlessSearchedUser[]>;
    /**
     * Gets the friends leaderboard
     * @returns The leaderboard, with position being index + 1
     * @async
     */
    getFriendsLeaderboard(): Promise<SearchedUser[]>;
    /**
     * Likes a Geometry Dash entity
     * @param id The object to like. This can be a level, account comment, or level comment
     * @returns Whether the liking succeeded
     * @async
     */
    like(id: SearchedLevel | AccountComment<User | StatlessSearchedUser> | LevelComment<User | StatlessSearchedUser>): Promise<boolean>;
    /**
     * Dislikes a Geometry Dash entity
     * @param id The object to dislike. This can be a level, account comment, or level comment
     * @returns Whether the disliking succeeded
     * @async
     */
    dislike(id: SearchedLevel | AccountComment<User | StatlessSearchedUser> | LevelComment<User | StatlessSearchedUser>): Promise<boolean>;
    /**
     * Likes a level
     * @param id The ID of the level to like (or the level itself)
     * @returns Whether the liking succeeded
     * @async
     */
    likeLevel(id: SearchedLevel | number): Promise<boolean>;
    /**
     * Dislikes a level
     * @param id The ID of the level to dislike (or the level itself)
     * @returns Whether the disliking succeeded
     * @async
     */
    dislikeLevel(id: SearchedLevel | number): Promise<boolean>;
    /**
     * Likes a comment
     * @param id The comment object to like
     * @returns Whether the liking succeeded
     * @async
     */
    likeComment(id: LevelComment<StatlessSearchedUser | User>): Promise<boolean>;
    /**
     * Likes a comment
     * @param id The ID of the comment to like
     * @param levelID The ID of the level the comment is on
     * @returns Whether the liking succeeded
     * @async
     */
    likeComment(id: number, levelID: SearchedLevel | number): Promise<boolean>;
    /**
     * Dislikes a comment
     * @param id The comment object to dislike
     * @returns Whether the disliking succeeded
     * @async
     */
    dislikeComment(id: LevelComment<StatlessSearchedUser | User>): Promise<boolean>;
    /**
     * Dislikes a comment
     * @param id The ID of the comment to dislike
     * @param levelID The ID of the level the comment is on
     * @returns Whether the disliking succeeded
     * @async
     */
    dislikeComment(id: number, levelID: SearchedLevel | number): Promise<boolean>;
    /**
     * Likes an account comment
     * @param id The account comment object to like
     * @returns Whether the liking succeeded
     * @async
     */
    likeAccountComment(id: AccountComment<StatlessSearchedUser | User>): Promise<boolean>;
    /**
     * Likes an account comment
     * @param id The ID of the account comment to like
     * @param accountID The account ID of the profile the comment is on
     * @returns Whether the liking succeeded
     * @async
     */
    likeAccountComment(id: number, accountID: StatlessSearchedUser | User | number): Promise<boolean>;
    /**
     * Dislikes an account comment
     * @param id The account comment object to dislike
     * @returns Whether the disliking succeeded
     * @async
     */
    dislikeAccountComment(id: AccountComment<StatlessSearchedUser | User>): Promise<boolean>;
    /**
     * Dislikes an account comment
     * @param id The ID of the account comment to dislike
     * @param accountID The account ID of the profile the comment is on
     * @returns Whether the disliking succeeded
     * @async
     */
    dislikeAccountComment(id: number, accountID: StatlessSearchedUser | User | number): Promise<boolean>;
    /**
     * Updates a level's description
     * @param levelID The level ID to update the description for
     * @param desc The new description for the level
     * @returns Whether or not the level description update succeeded
     */
    updateLevelDescription(levelID: number, desc: string): Promise<boolean>;
    /**
     * Updates a level's description
     * @param levelID The level object to update the description for
     * @param desc The new description for the level
     * @returns Whether or not the level description update succeeded
     */
    updateLevelDescription(levelID: SearchedLevel, desc: string): Promise<boolean>;
}
/**
 * Cosmetics of a user found by a search
 */
declare class SearchedUserCosmetics {
    /** The player's default icon */
    icon: {
        /** The numeric value of the icon, as provided by the Geometry Dash servers */
        val: number;
        /** The type of the icon */
        type: IconCosmetic;
    };
    /** The colors the player uses */
    colors: Colors;
    /**
     * Creates new info about a searched user's cosmetics
     * @param icon The number of the icon
     * @param iconType The type of the icon
     * @param colors The colors the player uses
     */
    constructor(
    /** @internal */
    _creator: UserCreator, icon: number, iconType: IconCosmetic, colors: Colors);
    /**
     * Renders the user's selected default icon as an image using the GDBrowser API
     * @param returnRaw Whether to return a raw Response (true) or an ArrayBuffer (false). Defaults to false.
     * @returns The Response or ArrayBuffer containing the image
     * @async
     */
    renderIcon(returnRaw?: false): Promise<ArrayBuffer>;
    /**
     * Renders the user's selected default icon as an image using the GDBrowser API
     * @param returnRaw Whether to return a raw Response (true) or an ArrayBuffer (false). Defaults to false.
     * @returns The Response or ArrayBuffer containing the image
     * @async
     */
    renderIcon(returnRaw: true): Promise<Response>;
}
/**
 * Details about a Geometry Dash player returned from a search, without any stats
 */
declare class StatlessSearchedUser {
    /** The player's username  */
    username: string;
    /** The player's user ID. Will only be present if it is known */
    id?: number;
    /** The player's account ID */
    accountID: number;
    /** The player's cosmetics */
    cosmetics: SearchedUserCosmetics;
    /**
     * Creates a searched user
     * @param _creator The searched user's creator
     * @param rawData The raw data to parse
     */
    constructor(
    /** @internal */
    _creator: UserCreator, rawData: string | ParsedData);
    /**
     * Get the most recent comment posted to this account's page
     * @returns The most recent comment
     * @async
     */
    getAccountComments(): Promise<AccountComment<this>>;
    /**
     * Get the comments posted to this account's page
     * @param num The maximum number of comments to get
     * @returns An array of this user's profile comments
     * @async
     */
    getAccountComments(num: number): Promise<AccountComment<this>[]>;
    /**
     * Gets the most recent or most liked level comment by the user
     * @param byLikes Whether to sort by likes or not. Defaults to false
     * @returns The most recent or most liked comment made by this user
     * @async
     */
    getComments(byLikes?: boolean): Promise<LevelComment<this>>;
    /**
     * Gets the most recent or most liked level comments by the user
     * @param byLikes Whether to sort by likes or not. Defaults to false
     * @param num The number of comments to get
     * @returns An array of the most recent or most liked comments made by this user
     * @async
     */
    getComments(byLikes: boolean, num: number): Promise<LevelComment<this>[]>;
    /**
     * Gets the most recent level by the user
     * @returns The most recent level made by this user
     * @async
     */
    getLevels(): Promise<this extends LoggedInUser ? LoggedInSearchedLevel : SearchedLevel>;
    /**
     * Gets the most recentlevels by the user
     * @param num The number of levels to get
     * @returns An array of the most recent levels made by this user
     * @async
     */
    getLevels(num: number): Promise<(this extends LoggedInUser ? LoggedInSearchedLevel : SearchedLevel)[]>;
    /**
     * Converts the searched user into a full user
     * @returns The full data about the user
     * @async
     */
    resolve(): Promise<User>;
}
/**
 * Details about a Geometry Dash player returned from a search
 */
declare class SearchedUser extends StatlessSearchedUser {
    /** The player's user ID */
    id: number;
    /** The player's stats */
    stats: {
        /** The number of stars the player has collected */
        stars: number;
        /** The number of demons the player has beaten */
        demons: number;
        /** The coins the player has collected */
        coins: {
            /** The number of coins in the single-player mode (gold coins) the player has collected */
            normal: number;
            /** The number of coins in user-created levels (silver coins) the player has collected */
            user: number;
        };
        /** The number of creator points the player has earned */
        cp: number;
    };
    /**
     * Creates a searched user with stats
     * @param _creator The searched user's raw data
     * @param rawData The raw data to parse
     */
    constructor(_creator: UserCreator, rawData: string);
}
/**
 * Credentials provided by a user
 */
export declare type UserCredentials = {
    /** The player's username */
    username: string;
    /** The player's password */
    password: string;
};
/**
 * A creator for Geometry Dash players
 */
declare class UserCreator extends Creator {
    /**
     * Find a player by accountID or username
     * @param id The account ID or username of the player to get
     * @returns The player with the provided account ID or username
     * @async
     */
    get(id: number | string | StatlessSearchedUser | User): Promise<User>;
    /**
     * Gets the information about a player using its account ID
     * @param id The account ID of the player to get
     * @returns The player with the provided account ID
     * @async
     */
    getByAccountID(id: number): Promise<User>;
    /**
     * Searches for a player with a given string in their names.
     * Note that the official Geometry Dash servers will always only return the player (if any) whose name is exactly the provided string.
     * @param str The string to search for
     * @returns The first user whose name matches the given string
     * @async
     * @deprecated
     */
    search(str: string): Promise<SearchedUser>;
    /**
     * Searches for players with a given string in their names.
     * Note that the official Geometry Dash servers will always only return the player (if any) whose name is exactly the provided string.
     * @param str The string to search for
     * @param num The maximum number of users to get
     * @returns The array of users whose names match the given string
     * @async
     * @deprecated
     */
    search(str: string, num: number): Promise<SearchedUser[]>;
    /**
     * Get information about a user by its username
     * @param str The name of the user to search for
     * @param resolve Whether to resolve the searched user into its full user, making another network request.
     * @returns The user with the given username
     * @async
     */
    getByUsername(str: string, resolve?: true): Promise<User>;
    /**
     * Get information about a user by its username
     * @param str The name of the user to search for
     * @param resolve Whether to resolve the searched user into its full user, making another network request.
     * @returns The user with the given username
     * @async
     */
    getByUsername(str: string, resolve: false): Promise<SearchedUser>;
    /**
     * Gets the top player of a user leaderboard
     * @param type The type of leaderboard to get
     * @returns The top player in the given leaderboard category
     * @async
     */
    getLeaderboard(creators?: boolean): Promise<SearchedUser>;
    /**
     * Gets a user leaderboard
     * @param type The type of leaderboard to get
     * @param num The number of entries to get.
     * @returns The leaderboard, with position being index + 1
     * @async
     */
    getLeaderboard(creators: boolean, num: number): Promise<SearchedUser[]>;
    /**
     * Log in to a Geometry Dash account
     * @param userCreds The username and password to log in with
     * @throws {TypeError} if credentials are invalid
     * @returns The logged in user associated with the provided credentials
     * @async
     */
    login(userCreds: UserCredentials): Promise<LoggedInUser>;
    /**
     * Log in to a Geometry Dash account using preprocessed credentials
     * @param creds The credentials to log in with
     * @throws {TypeError} if credentials are invalid
     * @returns The logged in user associated with the provided credentials
     * @async
     */
    authorize(creds: Credentials): Promise<LoggedInUser>;
}
export { User, LoggedInUser, SearchedUser, StatlessSearchedUser, UserCreator, Comment, LevelComment, AccountComment, LoggedInAccountComment, LoggedInLevelComment, FriendRequest, IncomingFriendRequest, OutgoingFriendRequest, ConvertibleToAccountID, MessageUser, SearchedMessage, Message, GDColor, PermissionLevel, Permission, SocialURL, IconCosmetic, Colors, UserCosmetics, Socials, SearchedUserCosmetics };
